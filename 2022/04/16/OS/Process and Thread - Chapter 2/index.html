<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Process and Thread - Chapter 2 | Childish Chen's Blog</title><meta name="keywords" content="学习笔记,操作系统课程"><meta name="author" content="Childish Chen"><meta name="copyright" content="Childish Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="“ 但永恒是不存在的，进程也一样。”  Process and ThreadProcessProcess ModelProcess is an executing program, including the current values of the program counter, stack, and data section. Process Creation4 Events that">
<meta property="og:type" content="article">
<meta property="og:title" content="Process and Thread - Chapter 2">
<meta property="og:url" content="http://inblaze.github.io/2022/04/16/OS/Process%20and%20Thread%20-%20Chapter%202/index.html">
<meta property="og:site_name" content="Childish Chen&#39;s Blog">
<meta property="og:description" content="“ 但永恒是不存在的，进程也一样。”  Process and ThreadProcessProcess ModelProcess is an executing program, including the current values of the program counter, stack, and data section. Process Creation4 Events that">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-04-16T12:22:00.000Z">
<meta property="article:modified_time" content="2022-05-04T10:15:31.894Z">
<meta property="article:author" content="Childish Chen">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="操作系统课程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://inblaze.github.io/2022/04/16/OS/Process%20and%20Thread%20-%20Chapter%202/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Process and Thread - Chapter 2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-04 18:15:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s4.ax1x.com/2022/03/03/bYXlxH.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Childish Chen's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Process and Thread - Chapter 2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-16T12:22:00.000Z" title="Created 2022-04-16 20:22:00">2022-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-04T10:15:31.894Z" title="Updated 2022-05-04 18:15:31">2022-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">课程：操作系统</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://s1.ax1x.com/2022/04/16/LYg2pq.png" alt="startimg"></p>
<blockquote>
<p>“ 但永恒是不存在的，进程也一样。”</p>
</blockquote>
<h1 id="Process-and-Thread"><a href="#Process-and-Thread" class="headerlink" title="Process and Thread"></a>Process and Thread</h1><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><h3 id="Process-Model"><a href="#Process-Model" class="headerlink" title="Process Model"></a>Process Model</h3><p>Process is an <strong>executing program</strong>, including <strong>the current values of the program counter</strong>, <strong>stack</strong>, and <strong>data section</strong>.</p>
<h3 id="Process-Creation"><a href="#Process-Creation" class="headerlink" title="Process Creation"></a>Process Creation</h3><h4 id="4-Events-that-Cause-Process-Creation"><a href="#4-Events-that-Cause-Process-Creation" class="headerlink" title="4 Events that Cause Process Creation"></a>4 Events that Cause Process Creation</h4><ol>
<li><strong>System initialization</strong></li>
<li><strong>Execution of a process-creation system call by a running process</strong></li>
<li><strong>A user request to create a new process</strong></li>
<li><strong>Initialization of a patch job</strong></li>
</ol>
<h4 id="Parent-and-Child"><a href="#Parent-and-Child" class="headerlink" title="Parent and Child"></a>Parent and Child</h4><ul>
<li>After <em>fork</em>, the two processes, the parent and the child, have the same <strong>memory image</strong>, the same <strong>environment strings</strong>, and the same <strong>open files</strong>.</li>
<li>Unix 系统中, 子进程先复制父进程的所有(fork), 再执行一个系统调用使子女成为新进程.(execve), Window 则使用CreateProcess系统调用同时完成上面两步</li>
<li>父子进程可以同时执行,也有可能父等待子</li>
</ul>
<h3 id="Process-Termination"><a href="#Process-Termination" class="headerlink" title="Process Termination"></a>Process Termination</h3><h4 id="4-conditions-that-terminate-process"><a href="#4-conditions-that-terminate-process" class="headerlink" title="4 conditions that terminate process"></a>4 conditions that terminate process</h4><ol>
<li>Normal Exit(Voluntary)： 运行结束，告知OS结束并再分配资源</li>
<li>Error Exit(Voluntary)：进程发现了一个错误并退出</li>
<li>Fatal Error(Involuntary)进程进行了一个错误操作，被OS强制退出，如除0，取非法地址</li>
<li>Killed by Another Process(Involuntary)：父进程、系统、其他优先级更高的进程杀死</li>
</ol>
<h4 id="In-what-situation-parent-may-terminate-child-processes"><a href="#In-what-situation-parent-may-terminate-child-processes" class="headerlink" title="In what situation parent may terminate child processes"></a>In what situation parent may terminate child processes</h4><p>级联终止：When the parent exits, the child must exit.</p>
<h3 id="Process-State"><a href="#Process-State" class="headerlink" title="Process State"></a>Process State</h3><h4 id="5-States"><a href="#5-States" class="headerlink" title="5 States"></a>5 States</h4><ol>
<li><strong>new</strong></li>
<li><strong>ready </strong>(runnable; temporarily stopped to let another process run).</li>
<li><strong>running</strong> (actually using the CPU at that instant).</li>
<li><strong>waiting/blocked</strong>(unable to run unless some external event happens).</li>
<li><strong>terminated/exit</strong></li>
</ol>
<h4 id="diagram-of-process-state-IMPORTANT"><a href="#diagram-of-process-state-IMPORTANT" class="headerlink" title="diagram of process state (IMPORTANT!!!)"></a>diagram of process state (IMPORTANT!!!)</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/2.jpg" alt="img"></p>
<h4 id="When-to-Switch"><a href="#When-to-Switch" class="headerlink" title="When to Switch"></a>When to Switch</h4><ol>
<li><strong>Clock Interrupt</strong>：操作系统确定当前正在运行的进程的执行时间是否已经超过了最大允许时间段（时间片，即进程在被中断前可以执行的最大时间段），如果超过了，进程必须切换到就绪态，调入另一个进程。</li>
<li><strong>I/O Interrupt</strong>：操作系统确定是否发生了I/O 活动。如果I/O 活动是一个或多个进程正在等待的事件，操作系统就把所有相应的阻塞态进程转换到就绪态（阻塞/挂起态进程转换到就绪/挂起态），操作系统必须决定是继续执行当前处于运行态的进程，还是让具有高优先级的就绪态进程抢占这个进程。</li>
<li><strong>Trap</strong>：与当前正在运行的进程所产生的错误或异常条件相关，如非法的文件访问。</li>
<li><strong>Memory Fault</strong>：处理器访问一个虚拟内存地址，且此地址单元不在内存中时，操作系统必须从外存中把包含这个引用的内存块（页或段）调入内存中。在发出调入内存块的I/O 请求之后，操作系统可能会执行一个进程切换，以恢复另一个进程的执行，发生内存失效的进程被置为阻塞态，当想要的块调入内存中时，该进程被置为就绪态。</li>
<li><strong>Supervisor Call</strong>：管理程序调度</li>
</ol>
<p>Textbook Example (P93):</p>
<p><img src="https://s1.ax1x.com/2022/04/05/qXJ7SP.png" alt="img2"></p>
<h4 id="Process-Control-Block-PCB"><a href="#Process-Control-Block-PCB" class="headerlink" title="Process Control Block(PCB)"></a>Process Control Block(PCB)</h4><p>使用PCB来储存进程的Context</p>
<p>It includes:</p>
<ul>
<li><p><strong>Process State</strong> 进程状态</p>
</li>
<li><p><strong>Process Counte</strong>r 程序计数器</p>
</li>
<li><p><strong>CPU Register</strong> CPU寄存器</p>
</li>
<li><p><strong>CPU Scheduling Information</strong> CPU调度信息</p>
</li>
<li><p><strong>Memory-management Information</strong> 内存管理信息</p>
</li>
<li><strong>Accounting Information</strong> 记账信息</li>
<li><strong>I/O Status Information</strong> I/O状态信息</li>
</ul>
<h4 id="Context-Switch"><a href="#Context-Switch" class="headerlink" title="Context Switch"></a>Context Switch</h4><ul>
<li>When CPU switches to another process, the system must <strong>save the state of the old process</strong> and <strong>load the saved state for the new process</strong>.</li>
<li>Context represented in PCB of a process, include <strong>CPU registers</strong>, <strong>process state</strong>, <strong>memory-management information</strong>.</li>
<li>Context-switch time is overhead. The system does no useful work while switching.</li>
<li>Time dependent on hardware support.</li>
</ul>
<p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/4.jpg" alt="img"></p>
<h4 id="Process-Scheduling-Queues"><a href="#Process-Scheduling-Queues" class="headerlink" title="Process Scheduling Queues"></a>Process Scheduling Queues</h4><ul>
<li><strong>Job Queue</strong>: set of all processes in the system.</li>
<li><strong>Ready Queue</strong>: set of processes residing in main memory, ready and waiting to execute.</li>
<li><strong>Device Queue</strong>: set of processes waiting for an I/O device.</li>
</ul>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h3><p>In traditional operating systems, each process has an address space and a single thread of control. In fact, that is almost the definition of a process. Nevertheless, in many situations, it is desirable to have multiple threads of control in the same address space running in quasi-parallel, as though they were (almost) separate processes (except for the shared address space).</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/qvXOb9"><img src="https://s1.ax1x.com/2022/04/06/qvXOb9.md.png" alt="qvXOb9.md.png"></a></p>
<ul>
<li><p>A thread (or lightweight process) is a basic unit of CPU utilization; it consists of:</p>
<ul>
<li><strong>Program Counter</strong></li>
<li><strong>Register Set</strong> </li>
<li><strong>Stack Space</strong></li>
</ul>
</li>
<li><p>A thread <strong>shares</strong> with its peer threads its:</p>
<ul>
<li><strong>Code Section</strong></li>
<li><strong>Data Section</strong></li>
<li><strong>Operating-system resources</strong></li>
</ul>
<p>collectively know as <strong>ONE</strong> task.</p>
</li>
<li><p>A traditional or heavyweight process is equal to a task with <strong>one</strong> thread.</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Per Process Items</th>
<th>Per Thread Items</th>
</tr>
</thead>
<tbody>
<tr>
<td>Address Space</td>
<td>Program Counter</td>
</tr>
<tr>
<td>Global Variables</td>
<td>Registers</td>
</tr>
<tr>
<td>Open Files</td>
<td>Stack</td>
</tr>
<tr>
<td>Child Processes</td>
<td>State</td>
</tr>
<tr>
<td>Pending Alarms</td>
<td></td>
</tr>
<tr>
<td>Signals and Signal handlers</td>
<td></td>
</tr>
<tr>
<td>Accounting Information</td>
</tr>
</tbody>
</table>
</div>
<p>Items <strong>shared</strong> by <strong>all threads in a process</strong>; items <strong>private</strong> to each <strong>thread</strong>.</p>
<h3 id="Implementing-Thread"><a href="#Implementing-Thread" class="headerlink" title="Implementing Thread"></a>Implementing Thread</h3><ul>
<li><p>Advantages:</p>
<ul>
<li>兄弟线程之间可以共享地址空间与全部的数据</li>
<li>占用空间小，切换时快捷</li>
<li>划分的资源少, 创建销毁更加容易</li>
<li>多CPU系统中，多线程是有益的</li>
<li>Cooperation of multiple threads in same job confers higher throughput and improved performance.</li>
<li>Applications that require sharing a common buffer (i.e., producer-consumer) benefit from thread utilization.</li>
</ul>
<p>In a multiple threaded task, while one server thread is blocked and waiting, a second thread in the same task can run.</p>
<p>Threads provide a mechanism that allows sequential processes to make blocking system calls while also achieving parallelism.</p>
</li>
<li><p>Application Strategy</p>
<ul>
<li>同时需要IO与处理的进程(eg. 文字处理)</li>
<li>大型服务器回应用户请求. 作业小而多</li>
</ul>
</li>
</ul>
<h3 id="Different-Levels-of-Threads"><a href="#Different-Levels-of-Threads" class="headerlink" title="Different Levels of Threads"></a>Different Levels of Threads</h3><h4 id="User-level-Thread"><a href="#User-level-Thread" class="headerlink" title="User-level Thread"></a>User-level Thread</h4><p>supported above the kernel, via a set of library calls at the user level (Project Andrew from CMU). The kernel knows nothing about the threads package. As far as the kernel is concerned. it is managing ordinary, single-threaded processes.<br>The operating system has process table to manage processes and each process has its own <strong>thread table</strong> to keep track of the threads in this process.</p>
<p>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/LS7pVI"><img src="https://s1.ax1x.com/2022/04/07/LS7pVI.md.png" alt="LS7pVI.md.png"></a></p>
<p><strong>Advantages</strong></p>
<ul>
<li><p>A user-level threads package <strong>can be implemented on an operating system that does not support threads</strong>.</p>
</li>
<li><p>No trap is needed, no context switch is needed, the memory cache need not to be flushed, and so on. These make thread scheduling very <strong>fast</strong>. </p>
</li>
<li>Thread switch needs <strong>less instruction</strong>.</li>
<li>They allow each process to have its own <strong>customized scheduling algorithm</strong>.</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>It is hard to <strong>implement blocking system calls</strong>.</li>
<li>I<strong>f a thread starts running, no other thread in that process will ever tun unless the first thread voluntarily gives up the CPU</strong>, because there’s no clock interrupts within a single process.</li>
</ul>
<h4 id="Kernel-level-Thread"><a href="#Kernel-level-Thread" class="headerlink" title="Kernel-level Thread"></a>Kernel-level Thread</h4><p><img src="https://my-pic-bed-1302358960.cos.ap-nanjing.myqcloud.com/Blog/202006/img/8.jpg" alt="kernel-level thread">)</p>
<p>The kernel has a thread table that keeps track of all the threads in the system.</p>
<p><strong>Advantages</strong></p>
<ul>
<li><strong>内核管理全部的线程，调度地更加灵活</strong>。如：当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程，也可以运行另一个进程中的线程，而在User-level thread中，run-time系统始终运行自己进程中的线程。</li>
<li>不需要新的非阻塞的系统调用</li>
</ul>
<ul>
<li><strong>Hybrid Implement</strong></li>
</ul>
<p>Use kernel-level threads and then multiplex user-level threads onto some or all of them.</p>
<p><img src="https://s1.ax1x.com/2022/04/10/LARCse.png" alt="Hybrid Implement"></p>
<h4 id="Pop-up-Thread"><a href="#Pop-up-Thread" class="headerlink" title="Pop-up Thread"></a>Pop-up Thread</h4><p>  每当一个新消息(指外界请求)进入时, 进程弹出线程解决, 解决后销毁进程.</p>
<p>  适用于类批处理任务, 如大型服务器回应用户请求. 作业小而多</p>
<p>  <strong>Advantages</strong></p>
<ul>
<li>Since they are brand new, <strong>they do not have any history</strong> - registers, stack, whatever — that must be restored.</li>
<li><strong>No switch</strong>.</li>
<li>It is  very <strong>quick</strong> to create such a thread. </li>
</ul>
<h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><p>When a computer is multiprogrammed, it frequently has multiple processes or threads competing for the CPU at the same time. This situation occurs whenever two or more of them are simultaneously in the ready state. If only one CPU is available, a choice has to be made which process to run next. The part of the operating system that makes the choice is called the <strong>scheduler</strong>, and the algorithm it uses is called the <strong>scheduling algorithm</strong>. </p>
<h3 id="Process-Behavior"><a href="#Process-Behavior" class="headerlink" title="Process Behavior"></a>Process Behavior</h3><p>Some processes, such as the one in the Fig. (a), spend most of their time computing, while other processes, such as the one shown in the Fig. (b). spend most of their time waiting for I/O. The former are called <strong>compute-bound</strong> or <strong>CPU-bound</strong>; the latter are called <strong>I/O-bound</strong>.</p>
<p><img src="https://s1.ax1x.com/2022/04/11/LVqOns.png" alt="processBehavior"></p>
<h3 id="When-to-Schedule"><a href="#When-to-Schedule" class="headerlink" title="When to Schedule"></a>When to Schedule</h3><ul>
<li>When <strong>a new process is created</strong>, a decision needs to be made <strong>whether to run the parent process or the child process.</strong></li>
<li>When <strong>a process exists</strong>, a decision needs to be made <strong>which process should be chosen to run from the set of ready processes</strong>.</li>
<li>When <strong>a process blocks on I/O, on a semaphore, or for some reason, another process has to be selected to run</strong>.</li>
<li>When <strong>an I/O interrupt occurs</strong>, a scheduling decision <strong>may be(译版说的是必须，这里打个问号)</strong> made. If the interrupt came from an I/O device that has now completed its work, some process that was blocked waiting for the I/O device may now be ready to run.</li>
</ul>
<h3 id="Categorize-Scheduling-Algorithms-Based-on-Environment"><a href="#Categorize-Scheduling-Algorithms-Based-on-Environment" class="headerlink" title="Categorize Scheduling Algorithms Based on Environment"></a>Categorize Scheduling Algorithms Based on Environment</h3><ul>
<li><strong>Batch System 批处理系统</strong></li>
<li><strong>Interactive System 交互式系统</strong></li>
<li><strong>Real Time System 实时系统</strong></li>
</ul>
<h3 id="Scheduling-Algorithm-Goals"><a href="#Scheduling-Algorithm-Goals" class="headerlink" title="Scheduling Algorithm Goals"></a>Scheduling Algorithm Goals</h3><h4 id="All-System"><a href="#All-System" class="headerlink" title="All System"></a>All System</h4><ul>
<li><strong>Fairness</strong> - giving each precess a fair share of the CPU</li>
<li><strong>Policy enforcement</strong> - seeing that stated policy is carried out</li>
<li><strong>Balance</strong> - keeping all parts of the system busy</li>
</ul>
<h4 id="Batch-Systems"><a href="#Batch-Systems" class="headerlink" title="Batch Systems"></a>Batch Systems</h4><ul>
<li><strong>Throughput</strong> - maximize jobs per hour</li>
<li><strong>Turnaround time</strong> - minimize time between submission and termination</li>
<li><strong>CPU utilization</strong> - keep the CPU busy all the time</li>
</ul>
<h4 id="Interactive-Systems"><a href="#Interactive-Systems" class="headerlink" title="Interactive Systems"></a>Interactive Systems</h4><ul>
<li><strong>Response time</strong> - respond to requests quickly</li>
<li><strong>Proportionality</strong> - meet users’ expectation</li>
</ul>
<h4 id="Real-time-Systems"><a href="#Real-time-Systems" class="headerlink" title="Real-time Systems"></a>Real-time Systems</h4><ul>
<li><p><strong>Meeting deadlines</strong> - avoid losing data</p>
</li>
<li><p><strong>Predictability</strong> - avoid quality degration in multimedia systems</p>
</li>
</ul>
<h3 id="Scheduling-in-Batch-System"><a href="#Scheduling-in-Batch-System" class="headerlink" title="Scheduling in Batch System"></a>Scheduling in Batch System</h3><h4 id="First-Come-First-Served"><a href="#First-Come-First-Served" class="headerlink" title="First-Come, First-Served"></a>First-Come, First-Served</h4><ul>
<li><strong>Advantages</strong><ul>
<li>It is easy to understand and equally easy to program.</li>
</ul>
</li>
<li><strong>Disadvantages</strong><ul>
<li>Low CPU utilization</li>
</ul>
</li>
</ul>
<h4 id="Shortest-Job-First"><a href="#Shortest-Job-First" class="headerlink" title="Shortest Job First"></a>Shortest Job First</h4><p>The shortest job first is optimal only when all the jobs are <strong>available simultaneously</strong>.</p>
<h4 id="Shortest-Remaining-Time-Next"><a href="#Shortest-Remaining-Time-Next" class="headerlink" title="Shortest Remaining Time Next"></a>Shortest Remaining Time Next</h4><p>With this algorithm, the scheduler always chooses the process whose remaining run time is the shortest.</p>
<h3 id="Scheduling-in-Interactive-System"><a href="#Scheduling-in-Interactive-System" class="headerlink" title="Scheduling in Interactive System"></a>Scheduling in Interactive System</h3><h4 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h4><p>每个进程被分配一个固定长度的<strong>时间片（quantum）</strong>，允许进程在该时间片内运行，若时间片耗尽则将其CPU剥夺分配给另一个进程，若在时间片耗尽前阻塞或结束则立即进行切换。</p>
<ul>
<li><strong>时间片大小的设置</strong><ul>
<li>过长：退化成First-Come, First-Served算法，CPU利用率低</li>
<li>过短：CPU浪费大量时间在频繁的Context Switch上</li>
</ul>
</li>
</ul>
<h4 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h4><p>Each process is assigned a priority, and the runnable process with the highest priority is allowed to run. If some processes have <strong>the same priority</strong>, <strong>round-robin scheduling</strong> is used.<br>静态优先级：优先级被确立后不改变<br>动态优先级：优先级变化。为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟中断降低当前进程的优先级。<br>优先级可以被静态赋予或动态赋予。</p>
<h4 id="Shortest-Process-Next"><a href="#Shortest-Process-Next" class="headerlink" title="Shortest Process Next"></a>Shortest Process Next</h4><p>We can minimize overall response time by <strong>running the shortest one first</strong>. The problem is figuring out which of the currently runnable processes is the shortest one.</p>
<p>One approach is to <strong>make estimates based on past behavior and run the process with the shortest estimated running time.</strong></p>
<p>$ T_{n+1}=\alpha \cdot T_{n-1} + (1-\alpha)\cdot T_{n}$</p>
<h4 id="Other-Scheduling-Algorithm"><a href="#Other-Scheduling-Algorithm" class="headerlink" title="Other Scheduling Algorithm"></a>Other Scheduling Algorithm</h4><ul>
<li>Multiple Queues</li>
<li>Guaranteed Scheduling</li>
<li>Lottery Scheduling</li>
<li>Fair-Share Scheduling</li>
</ul>
<h3 id="Scheduling-in-Real-Time-Systems"><a href="#Scheduling-in-Real-Time-Systems" class="headerlink" title="Scheduling in Real-Time Systems"></a>Scheduling in Real-Time Systems</h3><p>If there are <em>m</em> periodic events and event <em>i</em> occurs with period $P_i$ and requires $C_i$ sec of CPU times to handle each event, then the load can be handled only if</p>
<script type="math/tex; mode=display">
\sum^{m}_{i=1}{\frac{C_i}{P_i}}\leq1</script><blockquote>
<p> $P_i$ - 周期，事件必须在周期内完成</p>
<p> $C_i$ - 完成事件需要占用的CPU时间</p>
</blockquote>
<h2 id="InterProcess-Communication"><a href="#InterProcess-Communication" class="headerlink" title="InterProcess Communication"></a>InterProcess Communication</h2><h3 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h3><p>Situations where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called <strong>race conditions</strong>.</p>
<h3 id="Critical-Regions"><a href="#Critical-Regions" class="headerlink" title="Critical Regions"></a>Critical Regions</h3><p>The key to prevent races and in many other situations involving shared memory, shared files, and shared everything else is to find some way to prohibit more than one process from reading and writing the shared data at the same time. Put in other words, what we need is <strong>mutual exclusion</strong>, that is, some way of making sure that if one process is using a shared variable or a file, the other processes will be excluded from doing the same thing.</p>
<p> The part of the program where the shared memory is accessed is called the <strong>critical region</strong> or <strong>critical section</strong>.</p>
<p>If we could arrange matters such that no two processes were ever in their critical regions at the same time, we could avoid races.</p>
<p>Although this requirement avoids race conditions, it is not sufficient for having parallel processes cooperate correctly and efficiently using shared data. We need four conditions to hold to have a good solution:</p>
<ol>
<li>No two processes may be simultaneously inside their critical regions.</li>
<li>No assumptions may be made about speeds or the number of CPUs. (universality)</li>
<li>No process running outside its critical region may block any other process.</li>
<li>No process should have to wait forever to enter its critical region.</li>
</ol>
<h3 id="Mutual-Exclusion-with-Busy-Waiting"><a href="#Mutual-Exclusion-with-Busy-Waiting" class="headerlink" title="Mutual Exclusion with Busy Waiting"></a>Mutual Exclusion with Busy Waiting</h3><h4 id="Disabling-Interrupts"><a href="#Disabling-Interrupts" class="headerlink" title="Disabling Interrupts"></a>Disabling Interrupts</h4><p>On a single-processor system, the simplest solution is to have each process <strong>disable all interrupts just after entering its critical region and re-enable them just before leaving it</strong>. Thus, once a process has disabled interrupts, it can examine and update the shared memory without fear that any other process will intervene.</p>
<p><strong>Flaw</strong></p>
<ul>
<li>It is unwise to user process the power to turn off interrupts.</li>
<li>If the system is a multiprocessor(with two or more CPUs) disabling interrupts affects only the CPU that executed the disable instruction.</li>
</ul>
<p>However, it is frequently convenient for the kernel itself to disable interrupts for a few instructions while it is updating variables or especially lists.</p>
<p>In conclusion, disabling interrupts is often a useful technique within the operating system itself but is not appropriate as a general mutual exclusion mechanism for user processes.</p>
<h4 id="Lock-Variables"><a href="#Lock-Variables" class="headerlink" title="Lock Variables"></a>Lock Variables</h4><p>Consider having a single, shared (lock) variable, initially 0. When a process wants to enter its critical region, it first tests the lock. If the lock is 0, the process sets it to 1 and enters the critical region. If the lock is already 1, the process just waits until it becomes 0. Thus, a 0 means that no process is in its critical region, and a 1 means that some process is in its critical region.</p>
<p><strong>Flaw</strong></p>
<p>Lock variable itself is a critical region. Suppose that one process reads the lock and sees that it is 0. Before it can set the lock to 1, another process is scheduled, runs, and sets the lock to 1. When the first process runs again, it will also set the lock to 1, and two processes will be in their critical regions at the same time. <strong>Two or more processes can read and write the lock variable simultaneously. If they read the lock variable at the same time and find it is 0, they’ll set the lock to 1 and enter the critical region simultaneously.</strong></p>
<h4 id="Strict-Alternation"><a href="#Strict-Alternation" class="headerlink" title="Strict Alternation"></a>Strict Alternation</h4><p>Use a variable such as <em>turn</em> to keep rack of whose turn it is to enter the critical region and examine or update the shared memory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Process 0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(turn!=<span class="number">0</span>); <span class="comment">//wait</span></span><br><span class="line">    criticalRegion();</span><br><span class="line">    turn=<span class="number">1</span>;</span><br><span class="line">    noncriticalRegion();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Process 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(turn!=<span class="number">1</span>); <span class="comment">//wait</span></span><br><span class="line">    criticalRegion();</span><br><span class="line">    turn=<span class="number">0</span>;</span><br><span class="line">    noncriticalRegion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can find there is a loop testing the variable <em>turn</em>. Continuously testing a variable until some value appears is called <strong>busy waiting</strong>. It should usually be avoided, since <strong>it wastes CPU time</strong>. Only when there is a reasonable expectation that the wait will be short is busy waiting used. A<br>lock that uses busy waiting is called a <strong>spin lock</strong>.</p>
<p>In fact, this solution requires that <strong>the two or more processes strictly alternate in entering their critical regions</strong>, for example, in spooling files. Neither one would be permitted to spool two in a row. While this algorithm does avoid all races, it is not really a serious candidate as a solution because <strong>it violates condition 3</strong>.</p>
<h4 id="Peterson’s-Solution"><a href="#Peterson’s-Solution" class="headerlink" title="Peterson’s Solution"></a>Peterson’s Solution</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2 / * number of processes * /</span></span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="type">int</span> interested[N]; / * whose turn is it? * /</span><br><span class="line">/ * all values initially <span class="number">0</span> (FALSE) * /</span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span> / * process is 0 or 1 * /</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> other; / * number of the other process * /</span><br><span class="line">	other = <span class="number">1</span> − process; / * the opposite of process * /</span><br><span class="line">	interested[process] = TRUE; / * show that you are interested * /</span><br><span class="line">	turn = process; / * <span class="built_in">set</span> flag * /</span><br><span class="line">	<span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE); / * null statement * / ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span> / * process: who is leaving * /</span><br><span class="line">&#123;</span><br><span class="line">	interested[process] = FALSE; / * indicate departure from critical region * /</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now consider the case that both processes call enter region almost simultaneously. Both will store their process number in turn. Whichever store is done last is the one that counts; the first one is overwritten and lost. Suppose that process 1 stores last, so turn is 1. When both processes come to the while statement, process 0 executes it zero times and enters its critical region. Process 1 loops and does not enter its critical region until process 0 exits its critical region.</p>
<p>注1: 此处仅有两个进程, 因此other是非0即1的整型. 实际中表示所有其他的进程</p>
<h4 id="The-TSL-Instruction"><a href="#The-TSL-Instruction" class="headerlink" title="The TSL Instruction"></a>The TSL Instruction</h4><p>TSL(Test and Set Lock) requires a little help from hardware. </p>
<p>TSL依赖于下面这条汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TSL REGISTER,LOCK	//将LOCK变量复制到寄存器,并将LOCK设置为1</span><br><span class="line">//这个操作是原子性的,复制和赋值之间不会被中断</span><br><span class="line">//LOCK=0可访问,=1不可访问</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">	TSL REGISTER,LOCK	//将LOCK变量复制到寄存器,并将LOCK设置为1</span><br><span class="line">	CMP REGISTER #0		//(原来的LOCK是0吗?)</span><br><span class="line">	JNE enter_region	//原来就是1,别的正在使用,循环等待</span><br><span class="line">	RET					//原来是1, 可以使用</span><br><span class="line">	</span><br><span class="line">leave_region:</span><br><span class="line">	MOVE LOCK.#O		//用完了,设置为0</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p>When the <em>lock</em> is 1, the <strong>memory bus</strong> is locked.</p>
<p>The CPU executing the TSL instruction locks the <strong>memory bus</strong> to prohibit other CPUs from accessing memory until it is done.</p>
<p>下列算法将设法避免忙等待</p>
<h3 id="Sleep-and-Wakeup"><a href="#Sleep-and-Wakeup" class="headerlink" title="Sleep and Wakeup"></a>Sleep and Wakeup</h3><h4 id="Producer-consumer-Problem"><a href="#Producer-consumer-Problem" class="headerlink" title="Producer-consumer Problem"></a>Producer-consumer Problem</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100 <span class="comment">//number of slots in the number</span></span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//number of items int the buffer</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item=produce_item(); <span class="comment">//generate next item</span></span><br><span class="line">        <span class="keyword">if</span>(count=N)</span><br><span class="line">            sleep(); <span class="comment">//if the buffer is full, go to sleep</span></span><br><span class="line">        insert_item(item); <span class="comment">//put item in buffer</span></span><br><span class="line">        count=count+<span class="number">1</span>; <span class="comment">//increment count of items in buffer</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">            wakeup(consumer); <span class="comment">//once buffer is not empty, wake up the consumer.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">            sleep(); <span class="comment">// if the buffer is empty, go to sleep.</span></span><br><span class="line">        item=move_item(); <span class="comment">//take item out of buffer</span></span><br><span class="line">        count=count<span class="number">-1</span>; <span class="comment">//decrement count of items in buffer</span></span><br><span class="line">        <span class="keyword">if</span>(count==N<span class="number">-1</span>)</span><br><span class="line">            wakeup(producer); <span class="comment">//once buffer is not full, wake up the producer.</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	不断消费, 如果消费完了（count==0）就休眠</span></span><br><span class="line"><span class="comment">	缓冲区count--,如果缓冲区不满(count==N-1)就唤醒生产者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Flaw</strong></p>
<ul>
<li>假设当前<code>count</code>为0，Consumer在<code>if(count==0)</code>语句判断当前应当sleep，但还未执行下一行<code>sleep()</code>语句，CPU使用权就转移到了Producer，Producer生产完使<code>count++</code>变为1，并<code>wakeup(consumer)</code>，然而此时Consumer还未<code>sleep()</code>，因而此次唤醒丢失，然后CPU使用权又转回Consumer，Consumer进行<code>sleep()</code>，后续由于count不再达到1，Producer将没有机会调用<code>wakeup(consumer)</code>，Consumer会一直sleep，等到count达到N时，Producer也将<code>sleep()</code>，导致Producer和Consumer都永久进入sleep状态。</li>
<li>假设当前<code>count</code>为N，Producer在<code>if(count==N)</code>语句判断当前应当sleep，但还未执行下一行<code>sleep</code>语句，CPU使用权就转移到了Consumer，Consumer生产完使<code>count--</code>变为N-1，并<code>wakeup(producer)</code>，然而此时Producer还未<code>sleep()</code>，因而此次唤醒丢失，然后CPU使用权又转回Producer，Producer进行<code>sleep()</code>，后续由于count不再达到N-1，Consumer将没有机会调用<code>wakeup(producer)</code>，Producer会一直sleep，等到count达到0时，Consumer也将<code>sleep()</code>，导致Producer和Consumer都永久进入sleep状态。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>In <em>Dijkstra’s</em> proposal, a new variable type, which he called a <strong>semaphore</strong>, was introduced.</p>
<p>Semaphore is the number of <strong>resource</strong> <strong>saved</strong>. It is an <strong>integer variable</strong> and can only be accessed via two indivisible (<strong>atomic</strong>) operations.  </p>
<ul>
<li><strong>Binary Semaphore</strong>: Its value can only be <em>0</em> or <em>1</em>, which is mainly used to implement <strong>mutual exclusion</strong>.</li>
<li><strong>Semaphore（一般信号量）</strong>: Its value is <strong>the number of resource</strong>, which is used to implement <strong>collaboration</strong> and <strong>synchronization</strong> between processes.</li>
</ul>
<h4 id="Operation-down-and-up"><a href="#Operation-down-and-up" class="headerlink" title="Operation: down and up"></a>Operation: <em>down</em> and <em>up</em></h4><h5 id="Down-P"><a href="#Down-P" class="headerlink" title="Down(P)"></a>Down(P)</h5><ol>
<li>Decrement the number of <em>semaphore</em> (<code>S--</code>)</li>
<li>Check the value of <em>semaphore</em></li>
<li>If the <em>semaphore</em> is <strong>not a negative number</strong>, the process <strong>continue to work</strong>. Otherwise, the process will be <strong>blocked</strong>.</li>
</ol>
<p>也就是说，<em>down</em>操作会先<strong>申请消耗信号量(<em>semaphore—</em>)</strong>，然后检查减少后的semaphore是否是<strong>非负整数</strong>，若是则说明<strong>信号量足够，该进程成功分配到了信号量，进程继续运行</strong>，否则说明<strong>信号量已耗尽，进程需要阻塞来等待其他进程使用后释放信号量才有机会分配到</strong>。</p>
<h5 id="Up-V"><a href="#Up-V" class="headerlink" title="Up(V)"></a>Up(V)</h5><ol>
<li>Increment the number of <em>semaphore</em> (<code>S++</code>)</li>
<li>Check the value of <em>semaphore</em></li>
<li>If the <em>semaphore</em> is a <strong>negative number</strong>, <strong>a certain blocked process will be waken up</strong>.</li>
</ol>
<p>也就是说，<em>up</em>操作会先<strong>释放占用的信号量(<em>semaphore++</em>)</strong>，然后检查增加后的semaphore是否是<strong>非正整数</strong>，若是则说明<strong>还有blocked进程在等待<em>semaphore</em>，那么就需要唤醒某个进程来使用刚才释放的<em>semaphore</em></strong>，否则说明<strong>目前没有blocked进程在等待<em>semaphore</em> </strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S=m; <span class="comment">//信号量S,初值m表示最大提供m个进程使用</span></span><br><span class="line">down(S)</span><br><span class="line">&#123;</span><br><span class="line">	S--;</span><br><span class="line">	<span class="keyword">if</span>(S&lt;<span class="number">0</span>)</span><br><span class="line">		bloked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">up(S)</span><br><span class="line">&#123;</span><br><span class="line">	S++;</span><br><span class="line">	<span class="keyword">if</span>(S&lt;=<span class="number">0</span>)</span><br><span class="line">		wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些地方的算法(比如教材中) 并不支持S为负数的情况, S最低为0; 那种算法是在<em>up</em>操作唤醒进程后进程再次使用<em>down</em>操作. 基本思路是类似的.</p>
<h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><ul>
<li><em>Monitor</em> is a higher-level synchronization primitive. <em>Monitor</em> cannot be interrupted when it was running. </li>
<li><p>A <em>monitor</em> is a collection of procedures, variable, and data structures that are all grouped together in a special kind of module or package.</p>
</li>
<li><p>Processes may call the procedures in a <em>monitor</em> whenever they want to, but they cannot directly access the <em>monitor</em>‘s internal data structures from procedures declared outside the <em>monitor</em>. </p>
</li>
<li><p>Only one process can be active in a monitor at any instant.</p>
</li>
</ul>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer	<span class="comment">//一个管程</span></span><br><span class="line">	condition full, empty;</span><br><span class="line">	integer count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span>	<span class="comment">//管程中的插入函数</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> count =N <span class="keyword">then</span> wait(full);</span><br><span class="line">		insert_item(item);</span><br><span class="line">		count:=count +<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> count=<span class="number">1</span> <span class="keyword">then</span> signal(empty)	</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span>integer;			<span class="comment">//管程中的移除函数</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> count =<span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">		remove = remove_item;</span><br><span class="line">		count:=count-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> count=N-<span class="number">1</span> <span class="keyword">then</span> signal(full)</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	count :=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;				<span class="comment">//管程结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	item= produce_item;</span><br><span class="line">	ProducerConsumer.insert(item)		<span class="comment">//其他进程通过管程来访问临界区</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	item = ProducerConsumer.remove;		<span class="comment">//绕过管程而访问是不允许的</span></span><br><span class="line">	consume_item(item)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Barriers"><a href="#Barriers" class="headerlink" title="Barriers"></a>Barriers</h3><p><strong><em>Barriers</em></strong> is intended for <strong>groups of processes</strong> rather than two-process producer-consumer type situations. Some applications are divided into phases and have the rule that no process may proceed into the next phase until all processes are ready to proceed to the next phase.</p>
<p>This behavior may be achieved by placing a <strong><em>barrier</em></strong> at the end of each phase.</p>
<p><img src="https://s1.ax1x.com/2022/04/16/LtQbnS.png" alt="Barriers"></p>
<p>(a). Processes in a group approaching a barriar.</p>
<p>(b). All processes but one blocked at the barrier.</p>
<p>(c). When the last process arrives at the barrier, all of them are let through.</p>
<h3 id="Classical-IPC-Problems"><a href="#Classical-IPC-Problems" class="headerlink" title="Classical IPC Problems"></a>Classical IPC Problems</h3><h4 id="The-Producer-Consumer-Problem"><a href="#The-Producer-Consumer-Problem" class="headerlink" title="The Producer-Consumer Problem"></a>The Producer-Consumer Problem</h4><p>We solve it by <em>down</em> and <em>up</em>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100 <span class="comment">//number of slots in buffer</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore; <span class="comment">//semaphore is a special kind of int </span></span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//controls access to critical region</span></span><br><span class="line">semaphore empty=N; <span class="comment">//counts empty buffer slots</span></span><br><span class="line">semaphore full=<span class="number">0</span>; <span class="comment">//counts full buffer slots</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        item=produce_item(); <span class="comment">//generate item to put in buffer</span></span><br><span class="line">        down(&amp;empty); <span class="comment">//decrement count of empty slots</span></span><br><span class="line">        down(&amp;mutex); <span class="comment">//enter critical region</span></span><br><span class="line">        insert_item(item); <span class="comment">//put new item in buffer</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">//leave critical region</span></span><br><span class="line">        up(&amp;full); <span class="comment">//increment count of full slots</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        down(&amp;full); <span class="comment">//decrement count of full slots</span></span><br><span class="line">        down(&amp;mutex); <span class="comment">//enter critical region</span></span><br><span class="line">        item=remove_item(item); <span class="comment">//take item from buffer</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">//leave critical region</span></span><br><span class="line">        up(&amp;empty); <span class="comment">//increment count of empty slots</span></span><br><span class="line">    	consume_item(item); <span class="comment">//do something with the item</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Notice</strong>:</p>
<ul>
<li><em>down</em> first, <em>up</em> second</li>
<li>Producer <code>down(&amp;empty)</code>, <code>up(&amp;full)</code>; Consumer <code>down(&amp;full)</code>, <code>up(&amp;empty)</code></li>
<li>When <em>down</em>, always <em>down</em> full/empty first, <em>down</em> mutex second; When <em>up</em>, always <em>up</em> mutex first, <em>up</em> full/empty second.</li>
</ul>
<h4 id="The-Dining-Philosophers-Problem"><a href="#The-Dining-Philosophers-Problem" class="headerlink" title="The Dining Philosophers Problem"></a>The Dining Philosophers Problem</h4><p><img src="https://s1.ax1x.com/2022/04/16/Lt0kM4.png" alt="diningPhilosophers"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/low5252/article/details/104800671">参考博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N           5               <span class="comment">/* 哲学家数目 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT        (i+N-1)%N       <span class="comment">/* i的左邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT       (i+1)%N         <span class="comment">/* i的右邻号码 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING    0               <span class="comment">/* 哲学家正在思考 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY      1               <span class="comment">/* 哲学家想取得叉子 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING      2               <span class="comment">/* 哲学家正在吃面 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N];                       <span class="comment">/* 记录每个人状态的数组 */</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;                  <span class="comment">/* 临界区互斥 */</span></span><br><span class="line">semaphore s[N];                     <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span>             <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;   </span><br><span class="line">        think();                    <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        take_forks(i);              <span class="comment">/* 需要两把叉子，或者阻塞 */</span></span><br><span class="line">        eat();                      <span class="comment">/* 进餐 */</span></span><br><span class="line">        put_forks(i);               <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span>              <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span><br><span class="line">&#123;    </span><br><span class="line">    down(&amp;mutex);                   <span class="comment">/* 进人临界区 */</span></span><br><span class="line">    state[i]=HUNGRY;                <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">    test(i);                        <span class="comment">/* 试图得到两把叉子 */</span></span><br><span class="line">    down(&amp;s[i]);                    <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(i)</span>                   <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;mutex);                   <span class="comment">/* 进人临界区 */</span></span><br><span class="line">    state[i]=THINKING;              <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">    test(LEFT);                     <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">    test(RIGHT);                    <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">    up(&amp;mutex);                     <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(i)</span>                        <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(state[i]==HUNGRY &amp;&amp; state[LEFT]!=EATING&amp;&amp;state[RIGHT]!=EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state[i]=EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>s[i] - 哲学家i的信号量，s[i]==0时无法eat，s[i]==1时已拿到forks，进食就绪</li>
<li>test(i) - 当哲学家i为饥饿状态且左右的哲学家都没有在进食，可进入进食状态，并<code>up(&amp;s[i])</code></li>
<li>take_forks(i) - 先进入critical region并将状态调整为HUNGERY，<code>test(i)</code>试探是否能拿叉子，若得到的s[i]==0则说明没有拿到叉子，那么执行<code>down(&amp;s[i])</code>时就会被s[i]阻塞，若得到的s[i]==1则说明拿到了叉子，<code>down(&amp;s[i])</code>执行结束，进食完毕</li>
<li>put_forks(i) - 先进入critical region并将状态调整为THINKING，<code>test(LEFT)</code>,<code>test(RIGHT)</code>试探左右桌哲学家是否能拿叉子，能拿的话test时调用的<code>up(&amp;s[i])</code>就会唤醒被阻塞的哲学家</li>
</ul>
<h4 id="The-Readers-and-Writers-Problem"><a href="#The-Readers-and-Writers-Problem" class="headerlink" title="The Readers and Writers Problem"></a>The Readers and Writers Problem</h4><ol>
<li>允许多个读者可以同时对文件执行读操作</li>
<li>只允许一个写者往文件写信息</li>
<li>任一写者在进行写操作时不允许其他读者或写者工作</li>
<li>写者执行写操作前，应该让已有的读者或者写者全部退出</li>
</ol>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><p>一个读者试图进行读操作，如果这时正有其他读者进行读操作，他可以直接开始读，而不需要等待。</p>
<p>读者陆续到来，读者一到就能够开始读操作，而写者进程只能等待所有读者都退出才能够进行写操作</p>
<p><strong>Semaphores:</strong></p>
<ol>
<li>记录读者数量的整型变量readcount，初值为0，当值大于0时，表明有读者存在，写者不能进行写操作</li>
<li>互斥量rmutex，初值为1，用户保证多个读者进程对于readcount的互斥访问</li>
<li>互斥量dmutex，初值为1，用于控制写者进程对于数据区的互斥访问。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>;</span><br><span class="line">semaphore dmutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(rmutex);</span><br><span class="line">        <span class="keyword">if</span>(++readcount == <span class="number">1</span>) P(dmutex);</span><br><span class="line">        V(rmutex);</span><br><span class="line">        <span class="comment">//此处为读操作</span></span><br><span class="line">        P(rmutex);</span><br><span class="line">        <span class="keyword">if</span>(--readcount == <span class="number">0</span>) V(dmutex);</span><br><span class="line">        V(rmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(dmutex);</span><br><span class="line">        <span class="comment">// 此处为写操作</span></span><br><span class="line">        V(dmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h5><p>当写者和读者同时等待时，后续写者到达可以插队到等待的读者之前，只要等待队列中有写者，不管何时到达，都优先于读者被唤醒。</p>
<p>相对于读者优先，<strong>新增的Semaphore</strong>：</p>
<ol>
<li>互斥量readable，初值为1，用于控制写者到达时可以优先读者进入临界区</li>
<li>整型信号量 writecount，初值为0，表示当前写者的数量</li>
<li>互斥量wmutex，初值为1，用户控制写者互斥访问writecount</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore dmutex = <span class="number">1</span>;</span><br><span class="line">semaphore rmutex = <span class="number">1</span>;</span><br><span class="line">semaphore wmutex = <span class="number">1</span>;</span><br><span class="line">semaphore readable = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>, writecount = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">    P(readable);    <span class="comment">//检查是否有写者，若没有则占用，进行后续操作</span></span><br><span class="line">    P(rmutex);      <span class="comment">//占用rmutex，准备修改readcount</span></span><br><span class="line">    <span class="keyword">if</span>(++readcount == <span class="number">1</span>) P(dmutex); <span class="comment">//若是第一个读者，占用数据区</span></span><br><span class="line">    V(rmutex);      <span class="comment">//释放rmutex</span></span><br><span class="line">    V(readable);    <span class="comment">//释放readable</span></span><br><span class="line">    <span class="comment">// 此处为读操作</span></span><br><span class="line">    P(rmutex);      <span class="comment">//占用rmutex</span></span><br><span class="line">    <span class="keyword">if</span>(--readcount == <span class="number">0</span>) V(dmutex); <span class="comment">//若为最后一个读者，释放数据区</span></span><br><span class="line">    V(rmutex);      <span class="comment">//释放rmutex</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">    P(wmutex);      <span class="comment">//占用wmutex，准备修改writecount</span></span><br><span class="line">    <span class="keyword">if</span>(++writecount == <span class="number">1</span>) P(readable);  <span class="comment">//若为第一个写者，则占用readable，阻止后续读者进入</span></span><br><span class="line">    V(wmutex);      <span class="comment">//释放wmutex</span></span><br><span class="line">    P(dmutex);      <span class="comment">//占用dmutex，占用数据区</span></span><br><span class="line">    <span class="comment">// 此处为写操作</span></span><br><span class="line">    V(dmutex);      <span class="comment">//释放rmutex</span></span><br><span class="line">    P(wmutex);      <span class="comment">//占用wmutex，修改writecount</span></span><br><span class="line">    <span class="keyword">if</span>(--writecount == <span class="number">0</span>) P(readable);  <span class="comment">//若是最后一个写者，则释放readable允许后续读者进入</span></span><br><span class="line">    V(wmutex);      <span class="comment">//释放wmutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1625--H/p/12835837.html">读者写者问题参考Blog</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B/">操作系统课程</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/30/ComputerArchitecture/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20Chapter%204/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">指令系统与汇编语言</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/02/Vim/2022-04-2-Vimtutor%E7%AC%AC%E4%B8%83%E8%AE%B2/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Vimtutor第七讲</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/05/13/OS/Deadlocks%20-%20Chapter%206/" title="Deadlocks - Chapter 6"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">Deadlocks - Chapter 6</div></div></a></div><div><a href="/2022/05/29/OS/Memory%20Management%20-%20Chapter%203/" title="Memory Management - Chapter 3"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-29</div><div class="title">Memory Management - Chapter 3</div></div></a></div><div><a href="/2022/03/21/ComputerArchitecture/3.3%20%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97/" title="浮点数运算"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">浮点数运算</div></div></a></div><div><a href="/2022/03/21/ComputerArchitecture/%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E4%B9%98%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97/" title="整数、定点数的乘除法运算"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">整数、定点数的乘除法运算</div></div></a></div><div><a href="/2022/03/03/ComputerArchitecture/%E8%A1%A5%E7%A0%81%E3%80%81%E7%A7%BB%E7%A0%81%E3%80%818421BCD-2022/" title="补码、移码、8421BCD码"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-03</div><div class="title">补码、移码、8421BCD码</div></div></a></div><div><a href="/2022/04/30/ComputerArchitecture/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20Chapter%204/" title="指令系统与汇编语言"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">指令系统与汇编语言</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTYzNi8zMjEwMw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s4.ax1x.com/2022/03/03/bYXlxH.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Childish Chen</div><div class="author-info__description">Every great story begins with a vision.</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/inblaze"><i class="fab fa-github"></i><span>My Github Account</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Process-and-Thread"><span class="toc-number">1.</span> <span class="toc-text">Process and Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Process"><span class="toc-number">1.1.</span> <span class="toc-text">Process</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-Model"><span class="toc-number">1.1.1.</span> <span class="toc-text">Process Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-Creation"><span class="toc-number">1.1.2.</span> <span class="toc-text">Process Creation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Events-that-Cause-Process-Creation"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">4 Events that Cause Process Creation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parent-and-Child"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Parent and Child</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-Termination"><span class="toc-number">1.1.3.</span> <span class="toc-text">Process Termination</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-conditions-that-terminate-process"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">4 conditions that terminate process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#In-what-situation-parent-may-terminate-child-processes"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">In what situation parent may terminate child processes</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-State"><span class="toc-number">1.1.4.</span> <span class="toc-text">Process State</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-States"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">5 States</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diagram-of-process-state-IMPORTANT"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">diagram of process state (IMPORTANT!!!)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#When-to-Switch"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">When to Switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Process-Control-Block-PCB"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">Process Control Block(PCB)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context-Switch"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">Context Switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Process-Scheduling-Queues"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">Process Scheduling Queues</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread"><span class="toc-number">1.2.</span> <span class="toc-text">Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-Model"><span class="toc-number">1.2.1.</span> <span class="toc-text">Thread Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementing-Thread"><span class="toc-number">1.2.2.</span> <span class="toc-text">Implementing Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Different-Levels-of-Threads"><span class="toc-number">1.2.3.</span> <span class="toc-text">Different Levels of Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#User-level-Thread"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">User-level Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel-level-Thread"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Kernel-level Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pop-up-Thread"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Pop-up Thread</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scheduling"><span class="toc-number">1.3.</span> <span class="toc-text">Scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Process-Behavior"><span class="toc-number">1.3.1.</span> <span class="toc-text">Process Behavior</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#When-to-Schedule"><span class="toc-number">1.3.2.</span> <span class="toc-text">When to Schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Categorize-Scheduling-Algorithms-Based-on-Environment"><span class="toc-number">1.3.3.</span> <span class="toc-text">Categorize Scheduling Algorithms Based on Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduling-Algorithm-Goals"><span class="toc-number">1.3.4.</span> <span class="toc-text">Scheduling Algorithm Goals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#All-System"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">All System</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Batch-Systems"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">Batch Systems</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interactive-Systems"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">Interactive Systems</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Real-time-Systems"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">Real-time Systems</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduling-in-Batch-System"><span class="toc-number">1.3.5.</span> <span class="toc-text">Scheduling in Batch System</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#First-Come-First-Served"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">First-Come, First-Served</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shortest-Job-First"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">Shortest Job First</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shortest-Remaining-Time-Next"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">Shortest Remaining Time Next</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduling-in-Interactive-System"><span class="toc-number">1.3.6.</span> <span class="toc-text">Scheduling in Interactive System</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Round-Robin-Scheduling"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">Round-Robin Scheduling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Priority-Scheduling"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">Priority Scheduling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shortest-Process-Next"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">Shortest Process Next</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Other-Scheduling-Algorithm"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">Other Scheduling Algorithm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduling-in-Real-Time-Systems"><span class="toc-number">1.3.7.</span> <span class="toc-text">Scheduling in Real-Time Systems</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InterProcess-Communication"><span class="toc-number">1.4.</span> <span class="toc-text">InterProcess Communication</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Race-Conditions"><span class="toc-number">1.4.1.</span> <span class="toc-text">Race Conditions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Critical-Regions"><span class="toc-number">1.4.2.</span> <span class="toc-text">Critical Regions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutual-Exclusion-with-Busy-Waiting"><span class="toc-number">1.4.3.</span> <span class="toc-text">Mutual Exclusion with Busy Waiting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Disabling-Interrupts"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">Disabling Interrupts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock-Variables"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">Lock Variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strict-Alternation"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">Strict Alternation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peterson%E2%80%99s-Solution"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">Peterson’s Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-TSL-Instruction"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">The TSL Instruction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sleep-and-Wakeup"><span class="toc-number">1.4.4.</span> <span class="toc-text">Sleep and Wakeup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer-consumer-Problem"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Producer-consumer Problem</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.4.5.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Operation-down-and-up"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">Operation: down and up</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Down-P"><span class="toc-number">1.4.5.1.1.</span> <span class="toc-text">Down(P)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Up-V"><span class="toc-number">1.4.5.1.2.</span> <span class="toc-text">Up(V)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitors"><span class="toc-number">1.4.6.</span> <span class="toc-text">Monitors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Barriers"><span class="toc-number">1.4.7.</span> <span class="toc-text">Barriers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classical-IPC-Problems"><span class="toc-number">1.4.8.</span> <span class="toc-text">Classical IPC Problems</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Producer-Consumer-Problem"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">The Producer-Consumer Problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Dining-Philosophers-Problem"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">The Dining Philosophers Problem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Readers-and-Writers-Problem"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">The Readers and Writers Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">1.4.8.3.1.</span> <span class="toc-text">读者优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">1.4.8.3.2.</span> <span class="toc-text">写者优先</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/OS/Memory%20Management%20-%20Chapter%203/" title="Memory Management - Chapter 3"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Memory Management - Chapter 3"/></a><div class="content"><a class="title" href="/2022/05/29/OS/Memory%20Management%20-%20Chapter%203/" title="Memory Management - Chapter 3">Memory Management - Chapter 3</a><time datetime="2022-05-29T12:22:00.000Z" title="Created 2022-05-29 20:22:00">2022-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/OS/Deadlocks%20-%20Chapter%206/" title="Deadlocks - Chapter 6"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Deadlocks - Chapter 6"/></a><div class="content"><a class="title" href="/2022/05/13/OS/Deadlocks%20-%20Chapter%206/" title="Deadlocks - Chapter 6">Deadlocks - Chapter 6</a><time datetime="2022-05-13T12:22:00.000Z" title="Created 2022-05-13 20:22:00">2022-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/30/ComputerArchitecture/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20Chapter%204/" title="指令系统与汇编语言"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="指令系统与汇编语言"/></a><div class="content"><a class="title" href="/2022/04/30/ComputerArchitecture/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20Chapter%204/" title="指令系统与汇编语言">指令系统与汇编语言</a><time datetime="2022-04-30T15:02:00.000Z" title="Created 2022-04-30 23:02:00">2022-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/OS/Process%20and%20Thread%20-%20Chapter%202/" title="Process and Thread - Chapter 2"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Process and Thread - Chapter 2"/></a><div class="content"><a class="title" href="/2022/04/16/OS/Process%20and%20Thread%20-%20Chapter%202/" title="Process and Thread - Chapter 2">Process and Thread - Chapter 2</a><time datetime="2022-04-16T12:22:00.000Z" title="Created 2022-04-16 20:22:00">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/Vim/2022-04-2-Vimtutor%E7%AC%AC%E4%B8%83%E8%AE%B2/" title="Vimtutor第七讲"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vimtutor第七讲"/></a><div class="content"><a class="title" href="/2022/04/02/Vim/2022-04-2-Vimtutor%E7%AC%AC%E4%B8%83%E8%AE%B2/" title="Vimtutor第七讲">Vimtutor第七讲</a><time datetime="2022-04-02T03:24:00.000Z" title="Created 2022-04-02 11:24:00">2022-04-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Childish Chen</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div></div></body></html>